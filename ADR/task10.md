# Миграция на Cassandra

## Выбор сущностей
|Коллекция|Обоснование за|Обоснование против|Решение|
|--|--|--|--|
|Пользовательские сессии|Высокая скорость записи и чтения (каждый клик пользователя генерирует событие). Данные временные (TTL). Целостность отдельной сессии не критична. Гео-распределенность позволяет хранить сессии пользователя ближе к нему для низкой задержки.|-|Cassandra|
|События пользователя (клики, история просмотров)|Огромный объем данных, высокая скорость, данные только добавляются (читаются позже, пакетно). Модель данных, ориентированная на время (time-series), ключ партиционирования включает временную метку.|-|Cassandra|
|Каталог товаров|Высокая скорость чтения, редкие обновления, гео-распределение.|Для фильтрации понадобится посторение стороннего индекса.|Cassandra|
|Корзина|Высокая скорость чтения/записи, гео-распределение.|Требуется высокая консистентность на уровне отдельной корзины - изпользовать user_id как ключ партиционирования.|MongoDB|
|Остатки на складе|Высокая скорость чтения/записи, гео-распределение.|Требует транзакционности и высокой консистентности.|В идеале - классический SQL|
|Заказы|Высокая скорость чтения/записи, гео-распределение.|Требует транзакционности и высокой консистентности.|В идеале - классический SQL|
|Аналитика по продажам|Высокая скорость чтения/записи, гео-распределение.|Требует агрегатов.|В идеале - классический SQL, еще лучше - OLAP|

## Модель
### Пользовательские сессии
```cql
CREATE TABLE user_sessions (
    session_id UUID,
    user_id UUID, // Может быть NULL для анонимных сессий
    created_at TIMESTAMP,
    expires_at TIMESTAMP,
    session_data TEXT, // JSON-объект с данными сессии (например, содержимое корзины)
    PRIMARY KEY ((session_id))
) WITH default_time_to_live = 86400; // TTL = 24 часа
```
#### Обоснование ключей
- Ключ партиционирования: session_id
- - Каждая сессия уникальна и все ее данные хранятся в одной партиции. Это позволяет очень быстро находить все данные сессии по ее ID и обеспечивать строгую консистентность для операций в пределах этой партиции. session_id — это UUID, что гарантирует идеальное равномерное распределение партиций по всему кластеру. Вероятность "горячих партиций" стремится к нулю.
- Ключ кластеризации: отсутствует
- - В данной модели нам не нужна сортировка внутри партиции, так как мы всегда читаем и записываем всю данные сессии одним операциями (session_data как JSON blob). Это упрощает модель и ускоряет запись.

#### Защита от "горячих партиций"
Идеальная, так как ключ партиционирования является случайным UUID. Нагрузка на запись и чтение равномерно распределяется по всем узлам кластера.

#### Влияние решардинга
При добавлении нового узла партиции, основанные на session_id, перераспределятся максимально равномерно благодаря хэшированию. Так как каждая партиция независима, решардинг не вызовет проблем с согласованностью данных.

### События пользователя
```cql
CREATE TABLE user_events (
    user_id UUID,
    event_time TIMESTAMP,
    event_type TEXT,  // 'VIEW_ITEM', 'ADD_TO_CART', 'SEARCH'
    resource_id UUID, // ID товара, поискового запроса и т.д.
    details TEXT,     // JSON с дополнительными данными (цена, категория и пр.)
    PRIMARY KEY ((user_id, event_date), event_time, event_type)
) WITH CLUSTERING ORDER BY (event_time DESC, event_type ASC);
```

#### Обоснование ключей
- Ключ партиционирования: user_id, event_date
- - user_id гарантирует, что все события одного пользователя будут сгруппированы. Распределение равномерное, так как user_id — это UUID.
- - event_date (например, значение типа 2023-10-27) добавляется для предотвращения создания "горячих партиций" без него данные очень активного пользователя (бота) разрастались бы бесконечно, и одна партиция стала бы слишком большой и неэффективной. Разбивка по дате ограничивает размер партиции одним днем для одного пользователя.
- Ключ кластеризации: event_time DESC, event_type
- - event_time DESC: Самые свежие события физически хранятся в начале партиции. Это позволяет очень быстро находить последние действия пользователя (SELECT ... WHERE user_id=... AND event_date=... LIMIT 10).
- - event_type: Позволяет фильтровать события по типу прямо на уровне базы, минимизируя передаваемые данные.

#### Защита от "горячих партиций"
Ключ партиции включает детерминированную дату, что не дает одной партиции расти вечно.
user_id — это случайный UUID, что гарантирует равномерное распределение данных по кластеру.

#### Влияние решардинга
Добавление новых узлов приводит к перераспределению партиций по новому количеству узлов. Так как партиции имеют ограниченный размер (1 день * 1 пользователь), процесс решардинга будет равномерным и предсказуемым. Новая топология не создает дисбаланса.

### Каталог товаров
```cql
CREATE TABLE products (
    id UUID,
    name TEXT,
    description TEXT,
    price DECIMAL,
    category_id UUID,
    attributes MAP<TEXT, TEXT>, // Например, {'color': 'red', 'size': 'XL'}
    is_active BOOLEAN,
    created_at TIMESTAMP,
    PRIMARY KEY ((id))
);
```

#### Обоснование ключей
- Ключ партиционирования: id
- - id это UUID, что гарантирует равномерное распределение данных по всем узлам кластера. "Горячие" партиции исключены, так как каждый товар находится в своей собственной партиции.
- Ключ кластеризации: отсутствует
- - если мы (пока) решили не вести историю изменения, например, цены товара (с ключом по номеру версии или timestamp) - ключ кластеризации не нужен, он только усложнит модель, не добавив весомых бонусов. Если выходим на международный уровень - улючом кластеризации можно использовать локаль.

#### Защита от "горячих партиций"
"Горячие" партиции исключены, так как каждый товар находится в своей собственной партиции.

#### Влияние решардинга
При добавлении новых узлов партиции, основанные на id, будут перераспределены по кластеру максимально равномерно благодаря хэшированию.

### Каталог товаров в разрезе категорий
Для скорости работы пользователей (и с учетом особенности Cassandra) стоит пойти на дублирование данных: создать коллекцию товаров, индексированную категорией.
```cql
CREATE TABLE products_by_category (
    category_id UUID,
    product_id UUID,
    name TEXT,
    price DECIMAL,
    attributes MAP<TEXT, TEXT>, // Например, {'color': 'red', 'size': 'XL'},
    created_at TIMESTAMP,
    PRIMARY KEY ((category_id), created_at, product_id)
) WITH CLUSTERING ORDER BY (created_at DESC);
```

#### Обоснование ключей
- Ключ партиционирования: category_id
- - category_id группирует все товары одной категории в одну партицию. Это позволяет одним запросом получить все товары категории.
- Ключ кластеризации: created_at, product_id
- - created_at DESC: Позволяет получать самые новые товары в начале списка ("новинки в категории X").
- - product_id: Гарантирует уникальность и позволяет получить окончательную сортировку внутри одной даты.

#### Защита от "горячих партиций"
Здесь возможно появление горячих партиций, если есть популярная категория с огромным количеством товаров и запросов. Чтобы смягчить это, 
мы добавляем created_at как первый ключ кластеризации. Это не предотвращает попадание всех данных в одну партицию, но организует их внутри.

#### Влияние решардинга
Партиции, основанные на category_id, будут распределены по кластеру. При изменении топологии вся категория будет целиком перенесена на другой узел. Новая топология не создает дисбаланса.

#### Гарантия консисиентности
Реализовать согласованность данных двух таблиц товаров придется самостоятельно, Cassandra этого не гарантирует. Придется делать выбор:
- Атомарные пакетные записи.
- - Плюсы: простота реализации, гарантия атомарноного обновления таблиц в пакете.
- - Минусы: низкая производительность при масштабировании, узел-координатор может стать горячим, консистентность при ошибках не гарантируется (например, при ошибке диска)
- Паттерн "Очередь запросов" - CQRS.
- - Плюсы: высокая производительность и масштабируемость, отказоустойчивость, согласованность в конечном счёте.
- - Минусы: сложностью, не мгновенное обновление (согласованность, но в конечном счёте).

## Стратегии
|Коллекция|Стратегия|Обоснование|
|--|--|--|
|Пользовательские сессии|Hinted Handoff|Кратковременные данные. Если сессия не синхронизируется из-за падения узла, это не катастрофа — пользователь может перелогиниться. Скорость записи и доступность критичны.|
|События пользователя|Hinted Handoff|Потоковые данные. Потеря нескольких событий на фоне миллионов не исказит общую аналитическую картину, главное - тренд. Скорость записи — приоритет.|
|Каталог товаров|Read Repair|При обновении информации, read repair поможет быстрее распространить новое значение на все реплики при последующих чтениях.|
|Каталог товаров в разрезе категорий|Read Repair|При обновении информации, read repair поможет быстрее распространить новое значение на все реплики при последующих чтениях.|

### Anti-Entropy Repair
Суть - процедура обслуживания для выявления и исправления любых расхождений (глубокое и полное сравнение данных).
Его стоит запускать периодически (кроной) во время низкой нагрузки, т.к. это фоновый процесс, который может создавать значительную нагрузку на сеть и дисковую подсистему на время своего выполнения.
Например, в нашем случае - его стоит запускать для проверчи точности данных каталога товаров, выбраз расписание в зависимости от многих параметров.